# 23.买卖股票的最佳时机Ⅱ

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/


## 题目描述：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。**你可以尽可能地完成更多的交易（多次买卖一支股票）**。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

提示：

1 <= prices.length <= 3 * 10 ^ 4
0 <= prices[i] <= 10 ^ 4


## 思路：

本题和 买卖股票的最佳时机 的唯一区别**本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）**

在动规五部曲中，这个区别主要是体现在递推公式上，其他都和121. 买卖股票的最佳时机 (opens new window)一样一样的。

所以我们重点讲一讲递推公式。

这里重申一下dp数组的含义：

`dp[i][0]` 表示第i天持有股票所得现金。

`dp[i][1]` 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

第`i-1`天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`

第`i`天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

注意这里和 买卖股票的最佳时机 唯一不同的地方，就是推导`dp[i][0]`的时候，第`i`天买入股票的情况。

在  买卖股票的最佳时机 中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即`dp[i][0]`一定就是 `-prices[i]`。

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

那么第`i`天持有股票即`dp[i][0]`，如果是第`i`天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`。

在来看看如果第`i`天不持有股票即`dp[i][1]`的情况， 依然可以由两个状态推出来

第`i-1`天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`

第`i`天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

注意这里和 买卖股票的最佳时机 就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！

## 代码实现：

```java
    public int maxProfit(int[] prices) {
    /*    int len = prices.length;

        if(len < 2){
            return 0;
        }

        int[][] dp = new int[len][2];

        //第1天的时候默认手里有足够的现金,但初始化为0
        //第二个下标中，0 表示今天不持股 ； 1 表示今天持股，持股就需要减去第 1 天（下标为 0）的股价
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        //从第二天开始遍历
        for(int i = 1; i < len; i++){
            dp[i][0] = Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i]);
            //注意：本题股票可以买卖多次了
            dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - prices[i]);
        }

        return dp[len - 1][0];
     */

     // 优化空间 ：只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间
                int[] dp = new int[2];
                // 0表示持有，1表示卖出
                dp[0] = -prices[0];
                dp[1] = 0;
                for(int i = 1; i <= prices.length; i++){
                    // 前一天持有; 既然不限制交易次数，那么再次买股票时，要加上之前的收益
                    dp[0] = Math.max(dp[0], dp[1] - prices[i-1]);
                    // 前一天卖出; 或当天卖出，当天卖出，得先持有
                    dp[1] = Math.max(dp[1], dp[0] + prices[i-1]);
                }
                return dp[1];
    }
```

## 复杂度分析：
优化前：时空复杂度都是`O(N)`

优化后：空间复杂度变为`O(1)`
