# 7.不同搜索二叉树
https://leetcode-cn.com/problems/unique-binary-search-trees/

## 题目描述：
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 

示例 1：
![image](https://user-images.githubusercontent.com/82756242/154434412-e32305d6-feca-4b74-a4ab-1f377edd658d.png)


输入：n = 3
输出：5
示例 2：

输入：n = 1
输出：1
 

提示：

1 <= n <= 19

## 思路：
动态规划
  ### 1. 确定dp数组（dp table）以及下标的含义
        dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。
  ### 2. 确定递推公式：
        dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

        元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

        元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

        元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

        有2个元素的搜索树数量就是dp[2]。

        有1个元素的搜索树数量就是dp[1]。

        有0个元素的搜索树数量就是dp[0]。

        所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]
        
        在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

        j相当于是头结点的元素，从1遍历到i为止。

        所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
 
  ### 3.dp数组如何初始化 ： dp[0] = 1
  ### 4. 确定遍历顺序
        首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

        那么遍历i里面每一个数作为头结点的状态，用j来遍历。


## 代码：
class Solution {
          public int numTrees(int n) {
        //dp[i] :  1到i为节点组成的二叉搜索树的个数为dp[i]。
        int[] dp = new int[n+1];

        //状态转移方程：二叉搜索树 ： 左小右大
        // 推导过程：dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
        //元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
        //元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
        //元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
        // dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
        //j相当于是头结点的元素，从1遍历到i为止。
        //所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
        
        //初始化：dp[0] = 1
        dp[0] = 1;
        
        for(int i = 1 ; i <= n; i++){
            for(int j = 1 ; j <= i ;j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        
        return dp[n]; 
    }
}

## 复杂度分析：
时间复杂度：$O(n^2)
空间复杂度：$O(n)
