# 25.买卖股票的最佳时机Ⅳ

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/

## 描述：

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。**你最多可以完成 k 笔交易。**

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

提示：

0 <= k <= 100
0 <= prices.length <= 1000
0 <= prices[i] <= 1000

## 思路：

j的状态表示为：

0 表示不操作
1 第一次买入
2 第一次卖出
3 第二次买入
4 第二次卖出
.....

除了0以外，偶数就是卖出，奇数就是买入。

题目要求是至多有K笔交易，那么j的范围就定义为 2 * k  就可以了。


**强调一下：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票**

![image](https://user-images.githubusercontent.com/82756242/156997108-5d871215-aa3c-4d6d-a684-1d308ad79a32.png)


## 代码实现：
```java
    public int maxProfit(int k,int[] prices) {
        if(prices.length == 0)return 0;

        // [天数][股票状态]
        // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作
        //一共 0 ~（2*k） 共 （2*k + 1） 种状态
        int[][] dp = new int[prices.length][2 * k + 1];

        //初始化第 0 天的 买入状态 ； 第 0 天卖出操作 不符合题意，所以没必要初始化
        //dp[0][j]当j为奇数的时候都 表示为 第 j 次买入股票的操作
        for(int j = 1 ; j <= 2*k - 1 ; j += 2){
            dp[0][j] = -prices[0];
        }

        //dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票
        for(int i = 1 ; i < prices.length; i++){
            for (int j = 0; j <= 2 * k - 2 ; j += 2) {
                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        
        return dp[prices.length - 1][2 * k];
    }
```


## 复杂度分析：

时间复杂度：`O(n * min(n, k))`，其中 n 是给定数组` prices `的大小，即我们使用二重循环进行动态规划需要的时间。

空间复杂度：`O(n * min(n,k))`

