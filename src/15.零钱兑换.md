# 15.零钱兑换

https://leetcode-cn.com/problems/coin-change-2/

## 描述：
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

示例 1:

输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1

示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。

示例 3: 输入: amount = 10, coins = [10] 输出: 1

注意，你可以假设：

0 <= amount (总金额) <= 5000
1 <= coin (硬币面额) <= 5000
硬币种类不超过 500 种
结果符合 32 位符号整数

## 思路：

### 确定dp[]含义和下标的含义

`dp[j]`：凑成总金额`j`的货币组合数为`dp[j]`

### 确定状态转移方程

dp[j] （考虑coins[i]的组合总和） 就是所有的`dp[j - coins[i]]`（不考虑`coins[i]`）相加。

所以递推公式：`dp[j] += dp[j - coins[i]]`;  // 每一次 `dp[j]`都在更新

**注意：求装满背包有几种方法，一般公式都是：`dp[j] += dp[j - nums[i]]`;**

### dp数组如何初始化

首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。

从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。即 不凑

### 确定遍历顺序

本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？

在纯完全背包问题中，两个for循环的先后顺序都是可以的。

**但本题就不行了！**

因为纯完全背包求得是能否凑成总和，和凑成总和的元素顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求有顺序。

先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。

代码如下：
```java
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```
假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

所以这种情况，**凑成总和的元素是有顺序的！** 符合题意！

所以本题需要先 遍历物品，再 遍历背包容量

## 代码实现：
```java
    //完全背包的应用
    public int change(int amount, int[] coins) {
        int bagSize = coins.length;
        //dp[j]：凑成总金额j的货币组合数为dp[j]
        int[] dp = new int[amount + 1];

        dp[0]=1;

        for(int i = 0 ; i < bagSize; i++){
            for(int j = coins[i];j <= amount;j++){
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
```

## 复杂度分析：
时间复杂度：O(amount×n)，其中amount 是总金额，n 是数组 coins 的长度。

空间复杂度：O(amount)，其中 amount 是总金额。
