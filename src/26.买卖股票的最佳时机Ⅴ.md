# 26.买卖股票的最佳时机Ⅴ

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

## 描述：
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
**卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。**
示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]


## 思路：

        j的状态为：

        买入股票状态：
        0：状态一:买入股票状态（今天买入股票  或者是  之前就买入了股票然后保持状态）
        卖出股票状态：
        1：状态二:今天保持卖出股票状态,即 两天前就卖出了股票，度过了冷冻期，一直没操作
        2：状态三:今天 当天卖出了股票
        冷冻状态：
        3：状态四:今天为冷冻期状态，买不了但可卖，但冷冻期状态不可持续，只有一天！
        
       **注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态。** 
       
       
       
        
## 代码实现：
```java
    public int maxProfit(int[] prices) {
        /*
        j的状态为：

        买入股票状态：
        0：状态一:买入股票状态（今天买入股票  或者是  之前就买入了股票然后保持状态）
        卖出股票状态：
        1：状态二:今天保持卖出股票状态,即 两天前就卖出了股票，度过了冷冻期，一直没操作
        2：状态三:今天 当天卖出了股票
        冷冻状态：
        3：状态四:今天为冷冻期状态，买不了但可卖，但冷冻期状态不可持续，只有一天！
         */

        int[][] dp = new int[prices.length][4];

        //初始化第 0 天的状态,只需要初始化买入状态即可，第 0 天卖出不符合实际
        dp[0][0] = -prices[0];

        for(int i = 1 ; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0],Math.max(dp[i-1][3] - prices[i],dp[i-1][1] - prices[i]));
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][3]);
            dp[i][2] = dp[i-1][0] + prices[i];//今天当天卖出状态，则昨天是买入状态(当天或之前买)
            dp[i][3] = dp[i-1][2];
        }

        //最后结果是取 状态二，状态三，和状态四的最大值
        return Math.max(dp[prices.length - 1][1],Math.max(dp[prices.length - 1][2],dp[prices.length - 1][3]));
    }
```


## 复杂度分析：

时空复杂度：`O(n)`, n 就是给定数组的长度。
