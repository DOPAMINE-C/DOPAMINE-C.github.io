# 10. 分割等和子集
https://leetcode-cn.com/problems/partition-equal-subset-sum/

## 描述：
题目难易：中等

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].

示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.

提示：

1 <= nums.length <= 200
1 <= nums[i] <= 100

## 思路：
这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。

一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包。

要明确本题中我们要使用的是01背包，因为元素我们只能用一次。

回归主题：首先，本题要求集合里能否出现总和为 sum / 2 的子集。

那么来一一对应一下本题，看看背包问题如果来解决。

只有确定了如下四点，才能把01背包问题套到本题上来。

背包的体积为sum / 2
背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
背包如果正好装满，说明找到了总和为 sum / 2 的子集。
背包中每一个元素是不可重复放入。
以上分析完，我们就可以套用01背包，来解决这个问题了。

## 代码：
 /*
    01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。
    套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]。 target = sum/2
    如果dp[j] == j ,说明集合中的子集总和正好可以凑成总和j,所以 dp[j] <= j
     */
    public boolean canPartition(int[] nums) {
        int sum = 0;
        
        for(int i = 0 ; i < nums.length; i++){
            sum += nums[i];
        }
        int target = sum/2;
        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;

        int[] dp = new int[target + 1];
        int bagsize = nums.length;

        //i 代表给定集合中的 每个元素
        for(int i = 0 ; i < bagsize; i++){
            // 每一个元素一定是不可重复放入，所以从大到小遍历
            for(int j = target; j >= nums[i] ; j--){
                //物品 i 的重量是 nums[i]，其价值也是 nums[i]
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        return dp[target] == target;
    }
    
 ## 复杂度分析：
 时间复杂度：$O(n^2)$
 空间复杂度：$O(n)$，虽然dp数组大小为一个常数，但是大常数
